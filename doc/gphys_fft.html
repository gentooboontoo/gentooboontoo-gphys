<?xml version="1.0" ?>
<!DOCTYPE html 
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>../lib/numru/gphys/gphys_fft.rb</title>
</head>
<body>
<h1><a name="label:0" id="label:0">extention of class NumRu::GPhys -- Fast Fourier transformation and its applications</a></h1><!-- RDLabel: "extention of class NumRu::GPhys &shy;&shy; Fast Fourier transformation and its applications" -->
<p>This manual documents the methods of NumRu::GPhys defined in gphys_fft.rb</p>
<h1><a name="label:1" id="label:1">class methods</a></h1><!-- RDLabel: "class methods" -->
<dl>
<dt><h4><a name="label:2" id="label:2"><code>GPhys::fft_ignore_missing( <var>ignore</var>=<var>true</var>, <var>replace_val</var>=<var>nil</var> )</code></a></h4></dt><!-- RDLabel: "GPhys::fft_ignore_missing" -->
<dd>
<p>Set a flag (class variable) to ignore missing values. 
This is for data that do not have missing 
but is treated as potentially having missing (often
by having the valid_* attributes of NetCDF.)
If replace_val is specified, data missing with replaced
with that value.</p></dd>
</dl>
<h1><a name="label:3" id="label:3">methods</a></h1><!-- RDLabel: "methods" -->
<dl>
<dt><h4><a name="label:4" id="label:4"><code>fft(<var>backward</var>=<var>false</var>, *<var>dims</var>)</code></a></h4></dt><!-- RDLabel: "fft" -->
<dd>
<p>Fast Fourier Transformation (FFT) by using  
(<a href="http://www.fftw.org">FFTW</a>) ver 3 or ver 2.
A FFTW ver.2 interface is included in NArray, while
to use FFTW ver.3, you have to install separately.
Dimension specification by the argument dims is available
only with ver.3. By default, FFT is applied to all dimensions.</p>
<p>The transformation is complex. If the input data is not complex,
it will be coerced to complex before transformation.</p>
<p>When the FT is forward, the result is normalized 
(i.e., divided by the data number), unlike the default behavior of
FFTW.</p>
<p>Each coordinate is assumed to be equally spaced without checking.
The new coordinate variables will be set equal to wavenumbers,
derived as 2*PI/(length of the axis)*[0,1,2,..], where the length
of the axis is derieved as (coord.val.max - coord.val.min)*(n+1)/n.</p>
<p>ARGUMENTS</p>
<ul>
<li>backward (true of false) : when true, backward FT is done;
      otherwise forward FT is done.</li>
<li>dims (integers) : dimensions to apply FFT</li>
</ul>
<p>RETURN VALUE</p>
<ul>
<li>a GPhys</li>
</ul>
<p>EXAMPLE</p>
<pre>gphy.fft           # forward, for all dimensions
gphy.fft(true)     # backward, for all dimensions
gphy.fft(nil, 0,1) # forward, for the first and second dimensions.
gphy.fft(true, -1) # backward, for the last dimension.</pre></dd>
<dt><h4><a name="label:5" id="label:5"><code>detrend(<var>dim1</var>[,<var>dim2</var>[,...]])</code></a></h4></dt><!-- RDLabel: "detrend" -->
<dd>
<p>Remove means and linear trends along dimension(s) specified.
Algorithm: 1st order polynomial fitting.</p>
<p>ARGUMENTS</p>
<ul>
<li>dim? (Integer of String): the dimension along which you want to remove
      trends.</li>
</ul>
<p>RETURN VALUE</p>
<ul>
<li>a GPhys</li>
</ul>
<p>EXAMPLE</p>
<ul>
<li>See <a href="#label:5">detrend</a>.</li>
</ul></dd>
<dt><h4><a name="label:6" id="label:6"><code>cos_taper(<var>dim1</var>[,<var>dim2</var>[,...]])</code></a></h4></dt><!-- RDLabel: "cos_taper" -->
<dd>
<p>Cosine tapering along dimension(s) specified.</p>
<p>Algorithm: to multiply with the half cosine curves at the both 
1/10 ends of the data.</p>
<pre>cos taper shape:
         _____________
       _/             \_
     -&gt;   &lt;-       -&gt;   &lt;-
      T/10           T/10
   half-cosine     half-cosine
     shaped         shaped</pre>
<p>The spectra of tapered data should be multilied by 1/0.875,
which is stored as GPhys::COS_TAPER_SP_FACTOR (==1/0.875).</p>
<p>ARGUMENTS</p>
<ul>
<li>dim? (Integer of String): the dimension along which you want to remove
      trends.</li>
</ul>
<p>RETURN VALUE</p>
<ul>
<li>a GPhys</li>
</ul>
<p>EXAMPLE</p>
<pre>dim = 0    # for the 1st dimension
fc = gphys.detrend(dim).cos_taper(dim).fft(nil,dim)
sp = fc.abs**2 * GPhys::COS_TAPER_SP_FACTOR</pre></dd>
<dt><h4><a name="label:7" id="label:7"><code>spect_zero_centering(<var>dim</var>)</code></a></h4></dt><!-- RDLabel: "spect_zero_centering" -->
<dd>
<p>Shifts the waveneumber axis to cover from -K/2 to K/2 instead of 
from 0 to K-1, where the wavenumber is simbolically treated as integer,
which is actually not the case, though. Since the first (-K/2) and
the last (K/2) elements are duplicated, both are divided by 2.
Therefore, this method is to be used for spectra (squared quantity)
rather than the raw Fourier coefficients. (That is why the method name
is prefixed by "spect_").</p>
<p>The method is applied for a single dimension (specified by the argument
dim). If you need to apply for multiple dimensions, use it for multiple
times.</p>
<p>ARGUMENTS</p>
<ul>
<li>dim (integer): the dimension you want to shift spectra elements.
      Count starts from zero.</li>
</ul>
<p>RETURN VALUE</p>
<ul>
<li>a GPhys</li>
</ul>
<p>EXAMPLE</p>
<ul>
<li><p>To get a spectra of a variable var along the 1st and 2nd dimensions:</p>
<pre>fc = var.fft(nil, 0,1)    # --&gt; Fourier coef
sp = ( fc.abs**2 ).spect_zero_centering(0).spect_zero_centering(1)</pre>
<p>Note that spect_zero_centering is applied after taking |fc|^2.</p></li>
<li><p>Same but if you want to have the 2nd dimension one-sided:</p>
<pre>fc = var.fft(nil, 0,1)
sp = ( fc.abs**2 ).spect_zero_centering(0).spect_one_sided(1)</pre></li>
<li><p>Similar to the first example but for cross spectra:</p>
<pre>fc1 = var1.fft(nil, 0,1)
fc2 = var2.fft(nil, 0,1)
xsp = (fc1 * fc2.conj).spect_zero_centering(0).spect_zero_centering(1)</pre></li>
</ul></dd>
<dt><h4><a name="label:8" id="label:8"><code>spect_one_sided(<var>dim</var>)</code></a></h4></dt><!-- RDLabel: "spect_one_sided" -->
<dd>
<p>Similar to <a href="#label:7">spect_zero_centering</a> but to make one-sided spectra.
Namely, to convert from 0..K-1 to 0..K/2. To be applied for spectra;
wavenumber 2..K/2-1 are multiplied by 2.</p>
<p>ARGUMENTS</p>
<ul>
<li>dim (integer): the dimension you want to shift spectra elements.
      Count starts from zero.</li>
</ul>
<p>RETURN VALUE</p>
<ul>
<li>a GPhys</li>
</ul>
<p>EXAMPLE</p>
<ul>
<li>See the 2nd example of <a href="#label:7">spect_zero_centering</a>.</li>
</ul></dd>
<dt><h4><a name="label:9" id="label:9"><code>rawspect2powerspect(*<var>dims</var>)</code></a></h4></dt><!-- RDLabel: "rawspect2powerspect" -->
<dd>
<p>Converts raw spectra obtained by gphys.fft.abs**2 into
power spectra by dividing by wavenumber increments
along the dimensions spcified by dims.</p>
<p>ARGUMENTS</p>
<ul>
<li>dims (integers): the dimensions corresponding to wavenumbers.</li>
</ul>
<p>RETURN VALUE</p>
<ul>
<li>a GPhys</li>
</ul>
<p>EXAMPLE</p>
<ul>
<li><p>Suppose a 2 (or more) dimensional data gphys.</p>
<pre>fc = gphys.fft(nil, 0, 1)
sp = fc.abs**2
ps = sp.rawspect2powerspect(0,1)</pre>
<p>Here, sp is the raw spectum of gphys, and ps is the power spectrum.
The Parseval relation for them are as follows:</p>
<pre>(gphys**2).mean == sp.sum
                == pw.sum*dk*dl (== \int pw dk dl, mathematically),</pre>
<p>where, dk = (pw.coord(0)[1] - pw.coord(0)[0]), and
dl = (pw.coord(1)[1] - pw.coord(1)[0]).</p></li>
</ul></dd>
</dl>

</body>
</html>
